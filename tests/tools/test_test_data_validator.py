"""
Tests for Test Data Validator tool

Generated by the permissioned creation system.
"""

import unittest
from unittest.mock import Mock, patch
import sys
import os

# Add the parent directory to sys.path to allow imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from tools.test_data_validator import (
    test_data_validator,
    validate_test_data_validator_input,
)


class TestTestDataValidator(unittest.TestCase):
    """Test cases for Test Data Validator tool"""

    def setUp(self):
        """Set up test fixtures"""
        pass

    def test_tool_creation(self):
        """Test that the tool can be created and called"""
        test_params = {
            "data": "test_value",
            "format": "test_value",
            "strict": "test_value",
        }

        result = test_data_validator(**test_params)

        self.assertIsInstance(result, bool)

    def test_parameter_validation(self):
        """Test parameter validation"""
        # Test valid parameters
        valid_params = {
            "data": "test_value",
            "format": "test_value",
            "strict": "test_value",
        }

        self.assertTrue(validate_test_data_validator_input(**valid_params))

        # Test invalid parameters (missing required)
        invalid_params = {}
        self.assertFalse(validate_test_data_validator_input(**invalid_params))

    def test_successful_execution(self):
        """Test successful tool execution"""
        test_params = {
            "data": "test_value",
            "format": "test_value",
            "strict": "test_value",
        }

        result = test_data_validator(**test_params)

        self.assertIsInstance(result, bool)
        self.assertIsNotNone(result)

    def test_error_handling(self):
        """Test error handling with invalid input"""
        # Test with empty parameters
        with self.assertRaises(ValueError):
            test_data_validator()

        # Test with invalid parameter types
        invalid_params = {"data": None, "format": None, "strict": None}

        with self.assertRaises((ValueError, RuntimeError)):
            test_data_validator(**invalid_params)

    def test_tool_decorator(self):
        """Test that the tool is properly decorated"""
        # Check if the tool has the expected attributes from @tool decorator
        self.assertTrue(hasattr(test_data_validator, "name"))
        self.assertTrue(hasattr(test_data_validator, "description"))
        self.assertTrue(hasattr(test_data_validator, "args_schema"))

    def test_logging(self):
        """Test that the tool logs appropriately"""
        with self.assertLogs(level="INFO") as log:
            test_params = {
                "data": "test_value",
                "format": "test_value",
                "strict": "test_value",
            }

            test_data_validator(**test_params)

            # Check that logs were generated
            self.assertTrue(len(log.records) > 0)

    def test_return_type(self):
        """Test that the tool returns the expected type"""
        test_params = {
            "data": "test_value",
            "format": "test_value",
            "strict": "test_value",
        }

        result = test_data_validator(**test_params)

        # Check return type
        if bool == "str":
            self.assertIsInstance(result, str)
        elif bool == "int":
            self.assertIsInstance(result, int)
        elif bool == "float":
            self.assertIsInstance(result, (int, float))
        elif bool == "bool":
            self.assertIsInstance(result, bool)
        elif bool == "Dict[str, Any]":
            self.assertIsInstance(result, dict)
        elif bool == "List[str]":
            self.assertIsInstance(result, list)


if __name__ == "__main__":
    unittest.main()
